// Signals in computers are a way of communication between the process and the OS. When a running program undergoes some serious error then the OS sends a signal to the process and the process further may not execute.

// Signal and interrupt are basically the same but a small distinction exists i.e interrupts are generated by the processor and handled by the kernel but signals are generated by the kernel and handled by the process. Error signals generally cause termination of the program and a core dump file is created named core, which stores the state of the process at the moment of termination. 



// Example of 'SIGABRT' error

#include <stdio.h>

int main() {

	int arr[5] = {1, 2, 3, 4, 5};

	// SIGABRT error
	arr[6] = 6;

	return 0;
}

// 1. SIGFPE: This error signal denotes some arithmetic error that occurred like division by zero, or floating-point error. But this signal does not specify the type of floating-point error. 


// 2. SIGILL: This signal denotes illegal instruction. C does not produce illegal instruction so there is no chance of facing such an error signal, as the probable cause may be that the object file may be corrupted. 

// 3. SIGSEGV: 	The signal is only generated when a program goes far from its memory space so that it can be detected by the memory protection mechanism. The name is an abbreviation for “segmentation violation”. 

// 4. SIGBUS: The name is an abbreviation for “Bus error”. This signal is also produced when an invalid memory is accessed. It may seem to be the same as SIGSEGV but in SIGSEGV, the memory location referenced is valid but in the case of SIGBUS, memory referenced does not exist i.e de-referencing a memory location out of memory space. 

// 5. SIGSYS: This signal is sent to process when an invalid argument is passed to a system call. 

// 6. SIGTRAP: This signal is sent to process when an exception has occurred. This is requested by the debugger to get informed. For example, if a variable changes its value then this will trigger it. 

